module nat.def
module bar

syntax_category term

syntax syntax.equality
    sentence ::= term "=" term
end

syntax syntax.membership
    sentence ::= term "∈" term
end

syntax syntax.implication
    sentence ::= sentence "→" sentence
end

syntax syntax.existence
    sentence ::= "∃" @binding(term) "," sentence
end

syntax syntax.false
    sentence ::= "⊥"
end

syntax syntax.variable
    term ::= @variable(term)
end

syntax syntax.epsilon
    term ::= "ε" @binding(term) "," sentence
end

macro command.notation
    command ::= @kw"notation" $n:name $p:macro_pat "=>" $s:@template(sentence) @kw"end"
             => macro $n sentence ::= $p => $s end
end

macro command.definition
    command ::= @kw"definition" $n:name $p:macro_pat "=>" $t:@template(term) @kw"end"
             => macro $n term ::= $p => $t end
end

notation sentence.parens
    "(" $p:sentence ")" => $p
end

definition term.parens
    "(" $t:term ")" => $t
end

notation notation.neg
    "¬" $t:sentence => $t → ⊥
end

notation notation.or
    $p:sentence "∨" $q:sentence => (¬$p) → $q
end

notation notation.and
    $p:sentence "∧" $q:sentence => ¬((¬$p) ∨ (¬$q))
end

notation notation.iff
    $p:sentence "↔" $q:sentence => ($p → $q) ∧ ($q → $p)
end

notation notation.forall
    "∀" $x:name "," $p:sentence => ¬∃ $x, ¬$p
end

macro template.variable_shorthand
    template ::= "[" $n:name $a:maybe_template_params "]" => [$n$a:term]
end

macro template.sentence_shorthand
    template ::= "[" @kw"schema" $n:name $a:maybe_template_params "]" => [$n$a:sentence]
end

axiom fol.equality.intro [x] :
    |- x = x
end

axiom fol.equality.elim [x] [y] [schema 'p(term)] : (x = y) ('p(x))
    |- 'p(y)
end

axiom imp.intro [schema 'p] [schema 'q] : (assume 'p |- 'q)
    |- 'p → 'q
end

axiom modus_ponens [schema 'p] [schema 'q] : ('p) ('p → 'q)
    |- 'q
end

axiom exists.intro [schema 'p(term)] [y] : ('p(y))
    |- ∃x, 'p(x)
end

theorem eq.comm [x] [y] : (x = y)
    |- y = x
proof
    have x = x by fol.equality.intro [x];
    have y = x by fol.equality.elim [x] [y] [_ = x];
qed

theorem eq.trans [x] [y] [z] : (x = y) (y = z)
    |- x = z
proof
    have y = x by eq.comm [x] [y];
    have x = z by fol.equality.elim [y] [x] [_ = z];
qed

axiom and.intro [schema 'p] [schema 'q] : ('p) ('q)
    |- 'p ∧ 'q
end

axiom and.elim_left [schema 'p] [schema 'q] : ('p ∧ 'q)
    |- 'p
end

axiom and.elim_right [schema 'p] [schema 'q] : ('p ∧ 'q)
    |- 'q
end

theorem and.comm [schema 'p] [schema 'q] : ('p ∧ 'q)
    |- 'q ∧ 'p
proof
    have 'p by and.elim_left ['p] ['q];
    have 'q by and.elim_right ['p] ['q];
    
qed

-- definition if
    @kw"if" $p:sentence @kw"then" $t:term @kw"else" $f:term =>
        {x : x ∈ $t ∧ $p} ∪ {x : x ∈ $f ∧ ¬$p}
end

-- theorem if.true [schema p] [t] [f] : (p)
    |- if p then t else f = t
proof
    have h₁ := {x : x ∈ t ∧  p} = t by todo;
    have h₂ := {x : x ∈ f ∧ ¬p} = ∅ by todo;
    goal t ∪ ∅ = t by rw [h₁, h₂];
    by union_empty_set
qed

-- theorem if.false [schema p] [t] [f] : (¬p)
    |- if p then t else f = f
proof
    have h₁ := {x : x ∈ t ∧  p} = ∅ by todo;
    have h₂ := {x : x ∈ f ∧ ¬p} = f by todo;
    goal ∅ ∪ f = f by rw [h₁, h₂];
    by empty_set_union
qed

-- theorem if.either [schema p] [t] [f] :
    |- (if p then t else f = t) ∨ (if p then t else f = f)
proof
    have p ∨ ¬p by em [p];
    cases p ∨ ¬p
    ⬝  p => have if p then t else f = t by if.true;  by or.intro_left
    ⬝ ¬p => have if p then t else f = f by if.false; by or.intro_right
qed

-- theorem if.inverse [schema p] [t] [f] :
    |- if p then t else f = if ¬p then f else t
proof
    have p ∨ ¬p by em [p];
    cases p ∨ ¬p
    ⬝  p => 
        have if  p then t else f = t by if.true;
        have ¬¬p by double_negation;
        have if ¬p then f else t = t by if.false;
        by eq.trans
    ⬝ ¬p =>
        have if  p then t else f = f by if.false;
        have if ¬p then f else t = f by if.true;
        by eq.trans
qed
