module nat.def
module bar

syntax_category term

syntax syntax.equality
    sentence ::= term "=" term
end

syntax syntax.membership
    sentence ::= term "∈" term
end

syntax syntax.implication
    sentence ::= sentence "→" sentence
end

syntax syntax.existence
    sentence ::= "∃" @binding(term) "," sentence
end

syntax syntax.false
    sentence ::= "⊥"
end

syntax syntax.variable
    term ::= @variable(term)
end

syntax syntax.epsilon
    term ::= "ε" @binding(term) "," sentence
end

macro command.notation
    command ::= @kw"notation" $n:@name $p:macro_pat_list "=>" $s:@template(sentence) @kw"end"
             => macro $n sentence ::= $p => $s end
end

macro command.definition
    command ::= @kw"definition" $n:@name $p:macro_pat_list "=>" $t:@template(term) @kw"end"
             => macro $n term ::= $p => $t end
end

notation sentence.parens
    "(" $p:sentence ")" => $p
end

definition term.parens
    "(" $t:term ")" => $t
end

notation notation.neg
    "¬" $t:sentence => $t → ⊥
end

notation notation.or
    $p:sentence "∨" $q:sentence => ¬$p → $q
end

notation notation.and
    $p:sentence "∧" $q:sentence => ¬(¬$p ∨ ¬$q)
end

notation notation.iff
    $p:sentence "↔" $q:sentence => ($p → $q) ∧ ($q → $p)
end

notation notation.forall
    "∀" $x:@name "," $p:sentence => ¬∃ $x, ¬$p
end

macro template.variable_shorthand
    template ::= "[" $n:@name $a:maybe_template_params "]" => [$n$a:term]
end

macro template.sentence_shorthand
    template ::= "[" @kw"schema" $n:@name $a:maybe_template_params "]" => [$n$a:sentence]
end

macro template.param_shorthand
    template_param ::= $n:@name => $n : term
end

macro template.arg_shorthand
    template_arg ::= $t:term => $t : term
end

macro tactic_template.term_shorthand
    tactic_template ::= "[" $t:term "]" => [$t:term]
end

macro tactic_template.sentence_shorthand
    tactic_template ::= "[" "schema" $s:sentence "]" => [$s:sentence]
end

axiom fol.equality.intro [x] :
    |- x = x
end

axiom fol.equality.elim [x] [y] [schema 'p(_)] : (x = y) ('p(x))
    |- 'p(y)
end

axiom imp.intro [schema 'p] [schema 'q] : (assume 'p |- 'q)
    |- 'p → 'q
end

axiom modus_ponens [schema 'p] [schema 'q] : ('p) ('p → 'q)
    |- 'q
end

axiom exists.intro [schema 'p(_)] [y] : ('p(y))
    |- ∃x, 'p(x)
end

theorem eq.comm [x] [y] : (x = y)
    |- y = x
proof
    have x = x by fol.equality.intro [x];
    have y = x by fol.equality.elim [x] [y] [schema _ = x];
qed

theorem eq.trans [x] [y] [z] : (x = y) (y = z)
    |- x = z
proof
    have y = x by eq.comm [x] [y];
    have x = z by fol.equality.elim [y] [x] [schema _ = z];
qed

-- theorem false1 :
    |- ⊥
proof
    by false2
qed

-- theorem false2 :
    |- ⊥
proof
    
qed

-- theorem false3 :
    |- ⊥
proof
    by false3
qed
