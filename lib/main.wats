module nat.def
module bar

syntax_category term

syntax syntax.equality
    sentence ::= term "=" term
end

syntax syntax.membership
    sentence ::= term "∈" term
end

syntax syntax.implication
    sentence ::= sentence "→" sentence
end

syntax syntax.existence
    sentence ::= "∃" @binding(term) "," sentence
end

syntax syntax.false
    sentence ::= "⊥"
end

syntax syntax.variable
    term ::= @variable(term)
end

syntax syntax.epsilon
    term ::= "ε" @binding(term) "," sentence
end

macro command.notation
    command ::= @kw"notation" $n:name $p:macro_pat "=>" $s:@template(sentence) @kw"end"
             => macro $n sentence ::= $p => $s end
end

macro command.definition
    command ::= @kw"definition" $n:name $p:macro_pat "=>" $t:@template(term) @kw"end"
             => macro $n term ::= $p => $t end
end

notation sentence.parens
    "(" $p:sentence ")" => $p
end

definition term.parens
    "(" $t:term ")" => $t
end

notation notation.neg
    "¬" $t:sentence => $t → ⊥
end

notation notation.or
    $p:sentence "∨" $q:sentence => (¬$p) → $q
end

notation notation.and
    $p:sentence "∧" $q:sentence => ¬((¬$p) ∨ (¬$q))
end

notation notation.iff
    $p:sentence "↔" $q:sentence => ($p → $q) ∧ ($q → $p)
end

notation notation.forall
    "∀" $x:name "," $p:sentence => ¬∃ $x, ¬$p
end

macro template.variable_shorthand
    template ::= "[" $n:name $a:maybe_template_params "]" => [$n$a:term]
end

macro template.sentence_shorthand
    template ::= "[" @kw"schema" $n:name $a:maybe_template_params "]" => [$n$a:sentence]
end

axiom fol.equality.intro [x] :
    |- x = x
end

axiom fol.equality.elim [x] [y] [schema 'p(_)] : (x = y) ('p(x))
    |- 'p(y)
end

axiom imp.intro [schema 'p] [schema 'q] : (assume 'p |- 'q)
    |- 'p → 'q
end

axiom modus_ponens [schema 'p] [schema 'q] : ('p) ('p → 'q)
    |- 'q
end

axiom exists.intro [schema 'p(_)] [y] : ('p(y))
    |- ∃x, 'p(x)
end

theorem eq.comm [x] [y] : (x = y)
    |- y = x
proof
    have x = x by fol.equality.intro [x];
    have y = x by fol.equality.elim [x] [y] [_ = x];
qed

theorem eq.trans [x] [y] [z] : (x = y) (y = z)
    |- x = z
proof
    have y = x by eq.comm [x] [y];
    have x = z by fol.equality.elim [y] [x] [_ = z];
qed

axiom and.intro [schema 'p] [schema 'q] : ('p) ('q)
    |- 'p ∧ 'q
end

axiom and.elim_left [schema 'p] [schema 'q] : ('p ∧ 'q)
    |- 'p
end

axiom and.elim_right [schema 'p] [schema 'q] : ('p ∧ 'q)
    |- 'q
end

theorem and.comm [schema 'p] [schema 'q] : ('p ∧ 'q)
    |- 'q ∧ 'p
proof
    have 'p by and.elim_left ['p] ['q];
    have 'q by and.elim_right ['p] ['q];
    by and.intro ['q] ['p]
qed