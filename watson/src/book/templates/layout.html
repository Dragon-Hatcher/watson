<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{PAGE_TITLE}}</title>
    <link rel="stylesheet" href="styles.css" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css"
      integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <aside class="nav">{{SIDEBAR}}</aside>

    <article>{{CHAPTER_CONTENT}}</article>

    <script>
      // Current chapter number injected during generation
      const currentPage = "chapter-{{CHAPTER_NUM}}/";

      // Track visible sections and chapter header
      let visibleSections = new Set();
      let chapterHeaderVisible = false;

      function updateActiveSection() {
        // Remove all existing 'selected' classes
        document.querySelectorAll(".nav .selected").forEach((el) => {
          el.classList.remove("selected");
        });

        // Prioritize chapter header if visible
        if (chapterHeaderVisible || visibleSections.size == 0) {
          const chapterLink = document.querySelector(
            `.nav a[href="${currentPage}"]`
          );
          if (chapterLink) {
            chapterLink.classList.add("selected");
          }
        } else {
          // Find the topmost visible section
          const sections = Array.from(
            document.querySelectorAll('section[id^="section-"]')
          );
          let currentSection = null;

          for (const section of sections) {
            if (visibleSections.has(section.id)) {
              currentSection = section;
              break;
            }
          }

          if (currentSection) {
            const sectionId = currentSection.id;
            const sectionLink = document.querySelector(
              `.nav a[href="${currentPage}#${sectionId}"]`
            );
            if (sectionLink) {
              sectionLink.classList.add("selected");
            }
          }
        }
      }

      // Set up Intersection Observer to track section visibility
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.target.id === "chapter-header") {
              chapterHeaderVisible = entry.isIntersecting;
            } else if (entry.isIntersecting) {
              visibleSections.add(entry.target.id);
            } else {
              visibleSections.delete(entry.target.id);
            }
          });
          updateActiveSection();
        },
        {
          rootMargin: "-100px 0px -50% 0px",
          threshold: [0, 0.1, 0.5, 1],
        }
      );

      // Observe all section elements and chapter header
      window.addEventListener("load", () => {
        // Observe chapter header
        const chapterHeader = document.querySelector("#chapter-header");
        if (chapterHeader) {
          observer.observe(chapterHeader);
        }

        // Observe all sections
        document
          .querySelectorAll('section[id^="section-"]')
          .forEach((section) => {
            observer.observe(section);
          });

        updateActiveSection();
      });
    </script>
  </body>
</html>
